<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://jaeha-lee90.github.io/</id><title>Jaeha Lab</title><subtitle>Practical engineering notes from embedded platform bring-up, kernel/module analysis, and real-world automotive software workflows.</subtitle> <updated>2026-02-28T09:04:38-08:00</updated> <author> <name>jaeha.lee</name> <uri>https://jaeha-lee90.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://jaeha-lee90.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://jaeha-lee90.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2026 jaeha.lee </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>R사 X5H Day11 - Display Ownership (DomD vs DomA) 경계 고정</title><link href="https://jaeha-lee90.github.io/posts/r-company-x5h-day11-display-ownership-domd-vs-doma/" rel="alternate" type="text/html" title="R사 X5H Day11 - Display Ownership (DomD vs DomA) 경계 고정" /><published>2026-02-28T09:00:00-08:00</published> <updated>2026-02-28T09:00:00-08:00</updated> <id>https://jaeha-lee90.github.io/posts/r-company-x5h-day11-display-ownership-domd-vs-doma/</id> <content src="https://jaeha-lee90.github.io/posts/r-company-x5h-day11-display-ownership-domd-vs-doma/" /> <author> <name>jaeha.lee</name> </author> <category term="R사" /> <category term="X5H" /> <category term="Display" /> <category term="Bring-up" /> <summary> Day11은 Day10의 disfwk_fe Gate(A/B/C) 기준선 위에서, 화면 제어권을 DomD와 DomA 중 어디에 둘지 명확히 고정하는 데 집중한다. 목표는 “부팅은 되는데 화면이 간헐적으로 검정/깜빡임” 증상을 ownership 충돌 관점에서 빠르게 절단하는 것이다. 핵심 요약 초기 브링업 단계에서는 display ownership 단일화가 최우선이며, DomD 또는 DomA 중 한쪽만 최종 mode-set/commit 권한을 가져야 한다. DomD를 소유자로 두면 플랫폼 제어 일관성은 높지만, DomA UI 초기화 타이밍과의 인터페이스 계약이 필수다. DomA를 소유자로 두면 앱/UI 민첩성은 좋지만, 하이퍼바이저/가상화 경계에서 권한·복구 정책이 복잡해진다. 코드 포... </summary> </entry> <entry><title>R사 X5H Day10 - disfwk_fe 인터페이스/초기 표시 경로 분석</title><link href="https://jaeha-lee90.github.io/posts/r-company-x5h-day10-disfwk-fe-interface-flow/" rel="alternate" type="text/html" title="R사 X5H Day10 - disfwk_fe 인터페이스/초기 표시 경로 분석" /><published>2026-02-27T09:00:00-08:00</published> <updated>2026-02-27T09:00:00-08:00</updated> <id>https://jaeha-lee90.github.io/posts/r-company-x5h-day10-disfwk-fe-interface-flow/</id> <content src="https://jaeha-lee90.github.io/posts/r-company-x5h-day10-disfwk-fe-interface-flow/" /> <author> <name>jaeha.lee</name> </author> <category term="R사" /> <category term="X5H" /> <category term="Display" /> <category term="Bring-up" /> <summary> Day10은 Day9(KM/UM 정합 통과 조합) 기준선 위에서, 부팅 직후 화면이 실제로 살아나는 최소 경로를 disfwk_fe 중심으로 정리한다. 목표는 “GPU가 붙었는데 화면이 안 나온다” 문제를 display front-end 경계에서 빠르게 절단하는 것이다. 핵심 요약 disfwk_fe는 패널/출력 체인과 상위 그래픽 스택 사이의 front-end 접점으로 동작하며, 초기 표시 성공 여부는 probe → 리소스 바인딩 → 첫 frame commit 3단계로 수렴된다. 브링업 초반에는 기능 확장보다 초기 commit 성공/실패를 로그로 명확히 분기하는 것이 우선이다. Day9의 KM/UM 정합이 깨진 상태에서는 Day10 이슈를 정확히 분류할 수 없으므로, 입력 조건을 고정한 ... </summary> </entry> <entry><title>R사 X5H Day9 - ddk-um-bin 의존성과 KM/UM 버전 정합 실패 패턴</title><link href="https://jaeha-lee90.github.io/posts/r-company-x5h-day9-ddk-um-bin-dependency-version-compatibility/" rel="alternate" type="text/html" title="R사 X5H Day9 - ddk-um-bin 의존성과 KM/UM 버전 정합 실패 패턴" /><published>2026-02-26T09:00:00-08:00</published> <updated>2026-02-26T09:00:00-08:00</updated> <id>https://jaeha-lee90.github.io/posts/r-company-x5h-day9-ddk-um-bin-dependency-version-compatibility/</id> <content src="https://jaeha-lee90.github.io/posts/r-company-x5h-day9-ddk-um-bin-dependency-version-compatibility/" /> <author> <name>jaeha.lee</name> </author> <category term="R사" /> <category term="X5H" /> <category term="Display" /> <category term="GPU" /> <summary> Day9는 Day8의 커널 모듈 기준선을 이어서, 유저스페이스(ddk-um-bin)와 커널 모듈(pvrsrvkm) 사이 정합 실패를 조기에 차단하는 데 집중한다. 브링업 초반 GPU 이슈의 다수는 기능 결함보다 KM/UM 조합 불일치에서 시작된다. 핵심 요약 ddk-um-bin은 EGL/GLES/Vulkan 사용자 라이브러리와 PVRSRV 유저 컴포넌트를 제공하고, 런타임에 pvrsrvkm과 ioctls/bridge ABI로 결합된다. 빌드는 통과해도 KM/UM 빌드 베이스(DDK 태그, bridge 생성 산출물, feature 플래그)가 다르면 초기화 단계에서 즉시 실패하거나 간헐 크래시가 발생한다. 초기 게이트는 (1) 라이브러리 로딩 경로, (2) 드라이버 버전 문자열, (3) 서... </summary> </entry> <entry><title>R사 X5H Day8 - ddk-km 구조와 핵심 모듈 의존 관계</title><link href="https://jaeha-lee90.github.io/posts/r-company-x5h-day8-ddk-km-core-modules-dependency/" rel="alternate" type="text/html" title="R사 X5H Day8 - ddk-km 구조와 핵심 모듈 의존 관계" /><published>2026-02-25T09:00:00-08:00</published> <updated>2026-02-25T09:00:00-08:00</updated> <id>https://jaeha-lee90.github.io/posts/r-company-x5h-day8-ddk-km-core-modules-dependency/</id> <content src="https://jaeha-lee90.github.io/posts/r-company-x5h-day8-ddk-km-core-modules-dependency/" /> <author> <name>jaeha.lee</name> </author> <category term="R사" /> <category term="X5H" /> <category term="Display" /> <category term="GPU" /> <summary> Day8은 2주차(Display/GPU) 시작점으로, ddk-km/rogue_km의 빌드 진입점과 서비스 계층 의존 관계를 먼저 고정한다. 목표는 성능 튜닝이 아니라 GPU 커널 모듈의 안정 로딩 조건을 만드는 것이다. 핵심 요약 X5H 기준 ddk-km의 실질 진입점은 rogue_km/Makefile과 build/linux/x5h_android/Makefile 조합이며, 여기서 타깃/툴체인/커널 헤더 정합이 먼저 결정된다. 런타임 관점 핵심 경로는 pvrsrv 공통 서비스 레이어(services/server/common)와 RGX 디바이스 레이어(services/server/devices)의 결합이다. 브링업 초반에는 기능 확장보다 (1) 모듈 로드 성공, (2) 펌웨어 초기화 성공,... </summary> </entry> <entry><title>R사 X5H Day7 - 1주차 요약과 브링업 트리아지 체크리스트</title><link href="https://jaeha-lee90.github.io/posts/r-company-x5h-day7-week1-summary-triage-checklist/" rel="alternate" type="text/html" title="R사 X5H Day7 - 1주차 요약과 브링업 트리아지 체크리스트" /><published>2026-02-24T09:00:00-08:00</published> <updated>2026-02-24T09:00:00-08:00</updated> <id>https://jaeha-lee90.github.io/posts/r-company-x5h-day7-week1-summary-triage-checklist/</id> <content src="https://jaeha-lee90.github.io/posts/r-company-x5h-day7-week1-summary-triage-checklist/" /> <author> <name>jaeha.lee</name> </author> <category term="R사" /> <category term="X5H" /> <category term="Bring-up" /> <summary> Day1~Day6에서 정리한 boot chain, manifest 계층, kernel/module 로딩, android_device 초기화, 부팅 실패 패턴을 하나의 브링업 트리아지 절차로 통합한다. 목표는 “원인 탐색”보다 “재현 가능한 정상 부팅 확보”다. 핵심 요약 1주차 결론은 X5H 초기 브링업 이슈가 이미지 정합 → 커널 진입 → init/ueventd → 벤더 모듈 → 정책/권한 5단계 게이트에서 대부분 설명된다는 점이다. 디버깅 우선순위는 기능 완성보다 게이트 통과율 안정화(10회 재부팅 연속 성공)로 둔다. 트리아지는 “로그를 많이 보는 방식”이 아니라, 각 단계의 진입/탈출 신호를 체크하는 상태기계 방식이 시간 대비 효율이 가장 높다. 코드 포인트 Gate ... </summary> </entry> </feed>
