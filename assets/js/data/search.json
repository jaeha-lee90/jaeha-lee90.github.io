[ { "title": "R사 X5H Day11 - Display Ownership (DomD vs DomA) 경계 고정", "url": "/posts/r-company-x5h-day11-display-ownership-domd-vs-doma/", "categories": "R사, X5H, Display, Bring-up", "tags": "R사, X5H, Display, DomD, DomA, Bring-up", "date": "2026-02-28 09:00:00 -0800", "snippet": "Day11은 Day10의 disfwk_fe Gate(A/B/C) 기준선 위에서, 화면 제어권을 DomD와 DomA 중 어디에 둘지 명확히 고정하는 데 집중한다. 목표는 “부팅은 되는데 화면이 간헐적으로 검정/깜빡임” 증상을 ownership 충돌 관점에서 빠르게 절단하는 것이다.핵심 요약 초기 브링업 단계에서는 display ownership 단일화가 최우선이며, DomD 또는 DomA 중 한쪽만 최종 mode-set/commit 권한을 가져야 한다. DomD를 소유자로 두면 플랫폼 제어 일관성은 높지만, DomA UI 초..." }, { "title": "R사 X5H Day10 - disfwk_fe 인터페이스/초기 표시 경로 분석", "url": "/posts/r-company-x5h-day10-disfwk-fe-interface-flow/", "categories": "R사, X5H, Display, Bring-up", "tags": "R사, X5H, disfwk_fe, Display, Bring-up", "date": "2026-02-27 09:00:00 -0800", "snippet": "Day10은 Day9(KM/UM 정합 통과 조합) 기준선 위에서, 부팅 직후 화면이 실제로 살아나는 최소 경로를 disfwk_fe 중심으로 정리한다. 목표는 “GPU가 붙었는데 화면이 안 나온다” 문제를 display front-end 경계에서 빠르게 절단하는 것이다.핵심 요약 disfwk_fe는 패널/출력 체인과 상위 그래픽 스택 사이의 front-end 접점으로 동작하며, 초기 표시 성공 여부는 probe → 리소스 바인딩 → 첫 frame commit 3단계로 수렴된다. 브링업 초반에는 기능 확장보다 초기 commit..." }, { "title": "R사 X5H Day9 - ddk-um-bin 의존성과 KM/UM 버전 정합 실패 패턴", "url": "/posts/r-company-x5h-day9-ddk-um-bin-dependency-version-compatibility/", "categories": "R사, X5H, Display, GPU", "tags": "R사, X5H, ddk-um-bin, pvrsrvkm, Bring-up", "date": "2026-02-26 09:00:00 -0800", "snippet": "Day9는 Day8의 커널 모듈 기준선을 이어서, 유저스페이스(ddk-um-bin)와 커널 모듈(pvrsrvkm) 사이 정합 실패를 조기에 차단하는 데 집중한다. 브링업 초반 GPU 이슈의 다수는 기능 결함보다 KM/UM 조합 불일치에서 시작된다.핵심 요약 ddk-um-bin은 EGL/GLES/Vulkan 사용자 라이브러리와 PVRSRV 유저 컴포넌트를 제공하고, 런타임에 pvrsrvkm과 ioctls/bridge ABI로 결합된다. 빌드는 통과해도 KM/UM 빌드 베이스(DDK 태그, bridge 생성 산출물, featu..." }, { "title": "R사 X5H Day8 - ddk-km 구조와 핵심 모듈 의존 관계", "url": "/posts/r-company-x5h-day8-ddk-km-core-modules-dependency/", "categories": "R사, X5H, Display, GPU", "tags": "R사, X5H, ddk-km, GPU, Bring-up", "date": "2026-02-25 09:00:00 -0800", "snippet": "Day8은 2주차(Display/GPU) 시작점으로, ddk-km/rogue_km의 빌드 진입점과 서비스 계층 의존 관계를 먼저 고정한다. 목표는 성능 튜닝이 아니라 GPU 커널 모듈의 안정 로딩 조건을 만드는 것이다.핵심 요약 X5H 기준 ddk-km의 실질 진입점은 rogue_km/Makefile과 build/linux/x5h_android/Makefile 조합이며, 여기서 타깃/툴체인/커널 헤더 정합이 먼저 결정된다. 런타임 관점 핵심 경로는 pvrsrv 공통 서비스 레이어(services/server/common)와..." }, { "title": "R사 X5H Day7 - 1주차 요약과 브링업 트리아지 체크리스트", "url": "/posts/r-company-x5h-day7-week1-summary-triage-checklist/", "categories": "R사, X5H, Bring-up", "tags": "R사, X5H, Bring-up, Triage, Checklist", "date": "2026-02-24 09:00:00 -0800", "snippet": "Day1~Day6에서 정리한 boot chain, manifest 계층, kernel/module 로딩, android_device 초기화, 부팅 실패 패턴을 하나의 브링업 트리아지 절차로 통합한다. 목표는 “원인 탐색”보다 “재현 가능한 정상 부팅 확보”다.핵심 요약 1주차 결론은 X5H 초기 브링업 이슈가 이미지 정합 → 커널 진입 → init/ueventd → 벤더 모듈 → 정책/권한 5단계 게이트에서 대부분 설명된다는 점이다. 디버깅 우선순위는 기능 완성보다 게이트 통과율 안정화(10회 재부팅 연속 성공)로 둔다. ..." }, { "title": "R사 X5H Day6 - 기본 부팅 실패 포인트 체크리스트", "url": "/posts/r-company-x5h-day6-boot-failure-points-checklist/", "categories": "R사, X5H, Bring-up", "tags": "R사, X5H, Boot, Bring-up, Debug", "date": "2026-02-23 09:00:00 -0800", "snippet": "Day1~Day5에서 확인한 boot chain, manifest, kernel module, android_device 초기화 경로를 바탕으로, 초기 브링업에서 실제로 부팅을 멈추게 만드는 실패 지점을 우선순위로 정리한다.핵심 요약 X5H 초기 부팅 실패는 대체로 (1) 부팅 이미지/DTB 불일치, (2) early init 서비스 실패, (3) 벤더 모듈 로딩 실패, (4) 파티션/SELinux 정책 불일치 네 축으로 수렴한다. 디버깅 효율을 높이려면 로그를 순차적으로 보지 말고, bootloader → kernel →..." }, { "title": "R사 X5H Day5 - android_device init/ueventd/BoardConfig 브링업 크리티컬 포인트", "url": "/posts/r-company-x5h-day5-android-device-init-ueventd-boardconfig/", "categories": "R사, X5H, Bring-up, Android", "tags": "R사, X5H, Bring-up, android_device, init, ueventd, BoardConfig", "date": "2026-02-22 09:00:00 -0800", "snippet": "Day5는 초기 부팅 성공률에 직접 영향을 주는 android_device 레이어를 점검한다. 핵심은 init 서비스 기동 순서, ueventd 권한/노드 생성, BoardConfig 산출물 경계를 하나의 체인으로 보는 것이다.핵심 요약 BoardConfig는 “무엇을 빌드/포함할지”를 결정하고, init*.rc는 “언제/어떻게 띄울지”를 결정한다. 둘 중 하나만 맞아도 부팅 완성도가 떨어진다. ueventd.rc의 퍼미션/ownership 누락은 드라이버 자체 문제처럼 보이는 가짜 장애를 만든다. 브링업 초반에는 ser..." }, { "title": "R사 X5H Day4 - Manifest 책임 매트릭스와 벤더 모듈 로딩 경로", "url": "/posts/r-company-x5h-day4-manifest-responsibility-matrix-module-loading/", "categories": "R사, X5H, Bring-up, Kernel", "tags": "R사, X5H, Bring-up, Manifest, Kernel, Module", "date": "2026-02-21 09:00:00 -0800", "snippet": "Day4는 Day3의 후속으로, 브링업 초기에 가장 자주 꼬이는 지점인 manifest 책임 경계와 벤더 모듈 로딩 타이밍을 한 번에 정리했다.핵심 요약 android-manifest는 제품/플랫폼 전체 조합(상위 레이어), android-kernel-manifest는 커널/툴체인/외부모듈 결합(하위 레이어) 책임이 크다. 장애 triage는 “상위 조합 문제인지, 커널/모듈 결합 문제인지”를 1차 분기해야 시간을 줄일 수 있다. ddk-km, disfwk_fe는 커널 부팅 완료 이후 모듈 로딩 단계에서 실패가 드러나는 ..." }, { "title": "R사 X5H Day3 - android-kernel-manifest와 Xen 모듈 체인 분석", "url": "/posts/r-company-x5h-day3-kernel-manifest-xen-module-chain/", "categories": "R사, X5H, Kernel, Bring-up", "tags": "R사, X5H, Kernel, Manifest, Xen, Module", "date": "2026-02-20 09:00:00 -0800", "snippet": "Day3는 브링업 초기에 장애 확률이 높은 축인 커널 manifest 분리 구조 + 외부 모듈 결합 지점을 확인했다.핵심 요약 android-manifest와 별도로 android-kernel-manifest가 존재하며, 커널 빌드 입력은 여기서 고정된다. default.xml은 common-android14-6.1.xml + override.xml + proprietary.xml 3단 include 구조다. 베이스 커널은 common(xen-troops/linux, common-android14-6.1-xt)이고, Xe..." }, { "title": "R사 POC 관련 Git 커밋 9개 분석 (흐름·결정·다음 액션)", "url": "/posts/r-company-poc-9commit-analysis/", "categories": "R사, POC, Git", "tags": "X5H, IVI, BlogOps, CommitAnalysis, StudyLog", "date": "2026-02-20 06:20:00 -0800", "snippet": "이번 글은 최근 작업한 POC/스터디 관련 9개 커밋을 묶어서,1) 어떤 흐름으로 정리됐는지2) 무엇이 결정됐는지3) 다음에 뭘 하면 좋은지를 한 번에 보는 회고다.분석 대상 (시간순) 14638e5 docs: add X5H fusion POC architecture note and diagrams ce33e6c docs: add Renesas X5H repo study notes d0b7412 docs: keep blog Renesas-only and add index dcf51ba ci: update deprecat..." }, { "title": "R사 X5H Day2 - android-manifest 프로젝트 맵핑 스터디 (Product 5 + Kernel/Toolchain 5)", "url": "/posts/r-company-x5h-day2-android-manifest-project-map/", "categories": "R사, POC, Manifest, StudyLog", "tags": "X5H, Android, Repo, Manifest, Yocto, Kernel, Toolchain", "date": "2026-02-20 06:05:00 -0800", "snippet": "Day2는 기존 계획대로 POC 데모 9개 Git 스터디를 계속 진행하면서,그중 android-manifest를 깊게 파고들었다.이번 목표는 단순히 “프로젝트가 많다”가 아니라,실제로 빌드/통합 시 어떤 레이어를 먼저 봐야 하는지를 빠르게 판단할 수 있는 맵을 만드는 것이었다.1. 왜 android-manifest를 먼저 보는가android-manifest는 코드 그 자체보다,“어떤 코드 조합을 어떤 리비전으로 묶어 빌드할지”를 결정하는 구성의 진실 소스(Source of Truth)다. default.xml에서 포함(inc..." }, { "title": "DevOps 실무 플레이북 - Jenkins·Jira·Yocto·Confluence·JFrog·Codebeamer로 CI/CD/CT 운영하기", "url": "/posts/devops-ci-cd-ct-jenkins-jira-yocto-confluence-jfrog-codebeamer-playbook/", "categories": "Blogging, DevOps, StudyLog", "tags": "CI, CD, CT, Jenkins, Jira, Yocto, Confluence, JFrog, Codebeamer, Automotive", "date": "2026-02-20 05:40:00 -0800", "snippet": "임베디드/차량 SW 환경에서 DevOps를 적용할 때 가장 많이 부딪히는 문제는,“도구는 많은데 흐름이 끊긴다”는 점이다.이번 글은 아래 7개 도구를 하나의 운영 체계로 묶어서 보는 실무 정리다. Jenkins Jira Yocto Confluence JFrog Codebeamer (그리고 CI/CD/CT 운영 원칙)1) 큰 그림: CI/CD/CT를 분리해서 이해하기 CI (Continuous Integration) 코드 병합 시 빌드/정적검사/단위테스트를 자동 수행 목적: “깨진 코드가 ..." }, { "title": "C++ OOP Day1 분리본 - Student 클래스로 배우는 객체지향 기초", "url": "/posts/cpp-oop-day1-student-class/", "categories": "Blogging, OOP", "tags": "C++, OOP, Class, Encapsulation, Getter, Setter", "date": "2026-02-20 05:26:00 -0800", "snippet": "기존 통합 글에서 OOP 파트만 분리한 버전이다.오늘 목표는 C++ 클래스 문법을 가장 단순한 형태로 익히는 것.1) 클래스 핵심 개념 private: 데이터 보호 (직접 수정 방지) public: 외부에서 사용할 함수 생성자: 객체 만들 때 초기 상태 보장 getter/setter: 안전한 읽기/쓰기 통로classDiagram class Student { -string name -int score +Student(string n, int s) +setScore(int s) vo..." }, { "title": "C++ 코딩테스트 Day1 분리본 - 해시 패턴 4문제 (unordered_map/set)", "url": "/posts/cpp-codingtest-day1-hash-patterns/", "categories": "Blogging, CodingTest", "tags": "C++, LeetCode, unordered_map, unordered_set, Hash, 코딩테스트", "date": "2026-02-20 05:25:00 -0800", "snippet": "기존 통합 글에서 코딩테스트 파트만 분리한 버전이다.오늘은 해시 기반 문제 4개를 C++로 정리한다.왜 unordered_map / unordered_set를 먼저 쓰는가? 조회/삽입 평균 O(1) 중복 체크, 값-인덱스 매핑에 강함 코테에서 시간 단축에 매우 유리flowchart LR A[문제 요구사항] --&amp;gt; B{빠른 조회 필요?} B --&amp;gt;|Yes| C[unordered_set/map] B --&amp;gt;|No| D[정렬/순서 필요시 set/map]Day1 문제 1) Two Sum#..." }, { "title": "C++ 클래스(OOP) + 코딩테스트 30일 로드맵 (하루 2문제, 문법/알고리즘 동시 학습)", "url": "/posts/cpp-oop-and-codingtest-30day-roadmap/", "categories": "Blogging, CodingTest", "tags": "C++, OOP, LeetCode, Algorithm, 코딩테스트, 30일챌린지", "date": "2026-02-20 04:55:00 -0800", "snippet": "코딩테스트를 준비할 때 자주 생기는 문제가 있다. 알고리즘만 풀다 보면 C++ 클래스 문법이 약해지고, 문법만 공부하면 실전 문제 풀이 속도가 떨어진다.그래서 이번에는 30일 동안 하루 2문제만 풀면서,클래스(OOP) 문법과 알고리즘 패턴을 함께 가져가는 로드맵으로 정리했다.학습 방식 (핵심 규칙) 하루 2문제(총 60문제) 문제당 40분 제한 제출 후 반드시 정리 사용한 자료구조/알고리즘 시간복잡도/공간복잡도 실수 포인트 1줄 다음날 시작 전에 전날 틀린 문제 1개 복습..." }, { "title": "R사 X5H 코드 분석 Day 1 - Boot chain/IPL/firmware 흐름", "url": "/posts/r-company-x5h-day1-boot-chain-ipl-firmware/", "categories": "R사, X5H, Bring-up", "tags": "R사, X5H, Boot, IPL, Xen, Dom0, DomD", "date": "2026-02-19 09:00:00 -0800", "snippet": "30일 계획의 Day 1은 부팅 체인의 산출물 연결 관계를 먼저 고정하는 데 집중한다.핵심은 full.img/boot_artifacts에 들어가는 파일이 실제 U-Boot bootcmd와 1:1로 대응되는지 확인하는 것이다.핵심 요약 X5H 초기 부팅은 IPL(외부 SDK 기반) 이후, U-Boot에서 xen + xen.dtb + Image + uInitramfs + xenpolicy를 로드해 bootm으로 진입한다. meta-xt-x5h-dev/prod-devel-rcar-gen5.yaml의 boot_artifacts와 ..." }, { "title": "R사 X5H 코드 분석 30일 계획", "url": "/posts/r-company-30day-plan/", "categories": "R사, Plan", "tags": "R사, X5H, Bring-up, 30days", "date": "2026-02-19 01:20:00 -0800", "snippet": "초기 브링업 중요도를 기준으로 30일 분석 일정을 분할한다.Day 1-7 (Bring-up Core) Boot chain/IPL/firmware 흐름 Xen 부팅 경로 + Dom0/DomD 초기화 Android manifest 구조/동기화 전략 Kernel manifest + 외부 모듈 로딩 android_device의 init/ueventd/BoardConfig 기본 부팅 실패 포인트 정리 첫 주 요약 + 체크리스트Day 8-14 (Display/GPU) ddk-km 구조/핵심 모듈 ddk-um-bin 의존성..." }, { "title": "R사 Notes Index", "url": "/posts/r-company-index/", "categories": "R사", "tags": "R사, X5H, POC", "date": "2026-02-18 23:05:00 -0800", "snippet": "이 블로그는 지금부터 R사 관련 내용만 관리합니다.목록 R사 X5H 코드 분석 30일 계획 X5H Fusion POC 아키텍처 정리 R사 X5H Fusion POC Repo Study Notes R사 X5H 코드 분석 Day 1 - Boot chain/IPL/firmware 흐름 R사 X5H Day2 - android-manifest 프로젝트 맵핑 스터디 R사 X5H Day3 - android-kernel-manifest와 Xen 모듈 체인 분석 R사 X5H Day4 - Manifest 책임 매트릭스와 벤더 모듈 ..." }, { "title": "R사 X5H Fusion POC Repo Study Notes", "url": "/posts/renesas-x5h-repo-study-notes/", "categories": "R사, POC", "tags": "R사, X5H, Xen, Android, Yocto, Repo-Analysis", "date": "2026-02-18 22:35:00 -0800", "snippet": "이번에는 R사 partner GitLab의 X5H Fusion POC 관련 저장소들을 클론하고, 구성/역할/리스크를 빠르게 분석했다.분석 대상 (총 9개) android-kernel-manifest android-manifest android_device ddk-km ddk-um-bin disfwk_fe gen5-prebuilts meta-xt-gen5-platform meta-xt-x5h-dev큰 구조프로젝트는 크게 3계층으로 보였다.1) Manifest 계층 android-manifest: Android ..." }, { "title": "X5H Fusion POC 아키텍처 정리", "url": "/posts/x5h-fusion-poc-architecture/", "categories": "R사, POC", "tags": "Xen, Android, Linux, R사, Gen5, IVI", "date": "2026-02-18 21:20:00 -0800", "snippet": "이번 데모의 핵심은 Xen 위에 Android만 있는 구조가 아니라, Linux 도메인과 Android 도메인이 함께 동작하는 멀티 도메인 아키텍처라는 점이다.1) 전체 구조 Boot Chain: IPL → BL31 → OP-TEE → U-Boot Hypervisor: Xen 4.19 Domain 구성 Dom0 (Linux): 제어/오케스트레이션 DomD (Linux): 서비스/백엔드 도메인 DomA (Android 15): 앱/프레임워크 도메인 DomU (Linux): opti..." } ]
